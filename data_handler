import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns


#1. Get data

investment_universe = ['SPY', 'VTI', 'QQQ', 'EFA', 'AGG', 'VWO', 'IJR', 'IJH', 'IWF', 'GLD', 'LQD', 'TLT', 'VNQ', 'IEF', 'SHY', 'DIA', 'VGK', 'VB', 'EXS1.DE', 'CAC.PA']
num_assets = len(investment_universe)

print(f'Assets in investment universe: {num_assets}')



#2. Data pre-processing

df = yf.download(investment_universe, ignore_tz=True)['Adj Close']

# Check if at least 15x252 trading days are available (15 years * 252 trading days) 
trading_days = 15*252
non_null_counts = df.count()

for symbol in non_null_counts.index:
    if non_null_counts[symbol] < trading_days:
        print(f"Symbol {symbol} has less than {trading_days} non-null values: {non_null_counts[symbol]}")
    else:
        print(f"Ok! {symbol} has at least 15 years of data history ({non_null_counts[symbol]} days in total).")
        
# Prune whole df to match ETF with shortest history

min_counts = non_null_counts.min()
min_symbol = non_null_counts[non_null_counts == min_counts].index[0]
min_start_date = df[df[min_symbol].notnull()].index.min()
min_end_date = df[df[min_symbol].notnull()].index.max()
df = df.loc[(df.index >= min_start_date) & (df.index <= min_end_date)]
df = df.dropna()
#df = df.reset_index()
#df = df.drop(columns=['index'])
print(f"Shape of DataFrame after pruning: {df.shape}")

# Check if NaN values are in df

if df.isnull().values.any():
    print("NaN values present!")
else:
    print("DataFrame is clean.")
    
print(df.describe())



# 3. Show stock data

plt.style.use('dark_background')
plt.figure(figsize=(6, 9))
sns.lineplot(data=df, linewidth=0.8)
plt.ylabel('Price')
plt.xlabel('Trading Day')

#plt.show()

# 4. Calculate daily returns

log_returns = np.log(df / df.shift(1)).dropna()

#lets put both the returns and std into an ordered list and plot the values to get a first glance of our investment universe and how each individual asset performaned

return_ol = log_returns.mean().sort_values()
std_ol = log_returns.std().sort_values()
sr_ol = (return_ol/std_ol).sort_values()
risk_return_ol = pd.concat([return_ol, std_ol], axis=1)
risk_return_ol.columns = ['mean', 'std']


plt.style.use('dark_background')
plt.figure(figsize=(7, 8))
ax = sns.scatterplot(x=risk_return_ol['std'], y=risk_return_ol['mean'], hue=risk_return_ol.index, s=25, alpha=1, legend=False)
plt.xlabel('Standard Deviation')
plt.ylabel('Mean log Return')
plt.title('Mean vs.Std-Dev. (daily)')

for i, symbol in enumerate(risk_return_ol.index):
    ax.text(risk_return_ol.iloc[i]['std'], risk_return_ol.iloc[i]['mean'], symbol, fontsize=10)

#plt.show()

# Assuming return_ol and std_ol are your ordered lists
plt.style.use('dark_background')
fig, (ax1, ax2, ax3) = plt.subplots(nrows=3, figsize=(16,8))

# Plot for return_ol
sns.barplot(x=return_ol.index, y=return_ol.values, ax=ax1)
ax1.set_xlabel('Symbol')
ax1.set_ylabel('Mean log Return')

# Plot for std_ol
sns.barplot(x=std_ol.index, y=std_ol.values, ax=ax2)
ax2.set_xlabel('Symbol')
ax2.set_ylabel('Standard Deviation')

# Plot for sr_ol
sns.barplot(x=sr_ol.index, y=sr_ol.values, ax=ax3)
ax3.set_xlabel('Symbol')
ax3.set_ylabel('Mean / Std')

#plt.show()

